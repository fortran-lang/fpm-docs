# Copyright (C) 2021 Fortran programming language community
# This file is distributed under the same license as the fpm package.
# Sebastian Ehlert <awvwgk@disroot.org>, 2021.
# 左志华 <zuo.zhihua@qq.com>, 2021~2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: fpm \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-08-10 15:13+0200\n"
"PO-Revision-Date: 2022-01-13 14:45+0800\n"
"Last-Translator: 左志华 <zuo.zhihua@qq.com>\n"
"Language-Team: Fortran-Fans <https://github.com/fortran-fans>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

#: ../../pages/tutorial/dependencies.md:1
msgid "Adding dependencies"
msgstr "添加依赖项"

#: ../../pages/tutorial/dependencies.md:3
msgid ""
"This tutorial covers the usage of dependencies with fpm and how to reuse "
"existing fpm projects."
msgstr "本教程介绍如何用fpm处理依赖项及复用现有的fpm项目。"

#: ../../pages/tutorial/dependencies.md:5
msgid "Using the standard library"
msgstr "使用Fortran标准库"

#: ../../pages/tutorial/dependencies.md:7
msgid ""
"We start with a new project with fpm, we want to build a command line "
"application to read a file, find a certain pattern and replace it. Since "
"we do not want to write the replace function ourselves, we will use the "
"Fortran standard library ([stdlib](https://github.com/fortran-"
"lang/stdlib)) as dependency. In the package manifest we define *stdlib* "
"in the *dependencies* table:"
msgstr ""
"我们从一个使用fpm的新项目开始。我们想构建一个命令行应用程序来读取文件，找到某个模式（pattern）并替换它。由于我们不想自己编写替换函数，我们将使用Fortran标准库（[stdlib](https://github.com"
"/fortran-lang/stdlib)）作为*依赖项*。在包清单中，我们在依赖项表中定义*stdlib*："

#: ../../pages/tutorial/dependencies.md:11
#: ../../pages/tutorial/dependencies.md:77
#: ../../pages/tutorial/dependencies.md:112
#: ../../pages/tutorial/hello-fpm.md:33
msgid "fpm.toml"
msgstr ""

#: ../../pages/tutorial/dependencies.md:18
msgid ""
"Now we create a module with a procedure to perform the substitution. It "
"requires three steps:"
msgstr "现在，我们创建一个模块，其中包含执行替换的过程。它需要三个步骤："

#: ../../pages/tutorial/dependencies.md:21
msgid "reading a whole line from one unit"
msgstr "从文件通道读取整行；"

#: ../../pages/tutorial/dependencies.md:22
msgid "replace the pattern in the string"
msgstr "替换字符串中的模式；"

#: ../../pages/tutorial/dependencies.md:23
msgid "write the new string to an output"
msgstr "将新字符串写进输出通道。"

#: ../../pages/tutorial/dependencies.md:25
msgid ""
"We will use the *replace\\_all* function from the *stdlib\\_strings* "
"module for this purpose. The implementation is shown here"
msgstr "为此，我们将使用*stdlib_strings*模块中的*replace_all*函数。以下为代码实现："

#: ../../pages/tutorial/dependencies.md:28
msgid "src/demo.f90"
msgstr ""

#: ../../pages/tutorial/dependencies.md:33
msgid "Finally, we need a command line driver to make use of our new function."
msgstr "最后，我们需要一个命令行程序来使用我们的新函数。"

#: ../../pages/tutorial/dependencies.md:35
#: ../../pages/tutorial/dependencies.md:125
#: ../../pages/tutorial/hello-fpm.md:52
msgid "app/main.f90"
msgstr ""

#: ../../pages/tutorial/dependencies.md:54
msgid "We can check our command line driver by running it with fpm:"
msgstr "我们可以通过使用fpm运行命令行程序来检查它："

#: ../../pages/tutorial/dependencies.md:68
msgid "Adding a testing framework"
msgstr "添加测试框架"

#: ../../pages/tutorial/dependencies.md:70
msgid ""
"Before we continue implementing new features, we want to add some tests "
"to verify that our implementation keeps worked as we modify it. A "
"minimalist testing framework is available with [test-drive]. Since the "
"testing framework is only required when developing the package itself, "
"but not for other packages which might in the future make use of our "
"modules, we add a local dependency. The *test-drive* package is added in "
"the *dev-dependencies* table as shown below"
msgstr ""
"在继续实现新功能之前，我们希望添加一些测试，以验证我们的实现在修改后是否保持工作状态。有一个极简主义的测试框架——[test-"
"drive](https://github.com/fortran-lang/test-"
"drive)。由于测试框架仅在开发包本身时才需要，而对于将来可能使用我们的模块的其他包则不需要，我们添加了本地依赖项。*test-"
"drive*包将添加到开发依赖项表（*dev-dependencies*）中，如下所示："

#: ../../pages/tutorial/dependencies.md:85
msgid ""
"For a development dependency like a testing framework we choose a strict "
"version pin by specifying the *tag* we want to use."
msgstr "像测试框架这样的开发依赖关系，我们通过指定标记（*tag*）来选择严格的版本引脚。"

#: ../../pages/tutorial/dependencies.md:88
msgid ""
"Now we can write a simple unit test, since our function works with units,"
" we will create scratch units to create the input and capture the output."
" For now we will add a simple one line substitution as single test case"
msgstr "现在我们可以编写一个简单的单元测试。因为我们的函数执行需要文件通道，我们将创建暂存（scratch）通道来创建输入并捕获输出。现在，我们将添加一个简单的单行替换作为单个测试用例："

#: ../../pages/tutorial/dependencies.md:91
msgid "test/main.f90"
msgstr ""

#: ../../pages/tutorial/dependencies.md:96
msgid "We run our new test using fpm"
msgstr "我们使用fpm运行新测试："

#: ../../pages/tutorial/dependencies.md:104
msgid ""
"Creating the scratch units for multiple unit tests will be repetitive, "
"this kind of tasks can usually be done in a separate procedure and reused"
" in several tests."
msgstr "在多个单元测试中创建暂存通道比较繁琐，通常会在一个单独的过程中创建它们，然后在多个测试中重用。"

#: ../../pages/tutorial/dependencies.md:107
msgid "Target-specific dependencies"
msgstr "目标特定的依赖项"

#: ../../pages/tutorial/dependencies.md:109
msgid ""
"Dependencies can also be used for specific targets only. This can be used"
" for adding a command line interface package, which is only used for the "
"executable but not part of the library dependencies."
msgstr "依赖项也只能用于特定目标。这可用于添加命令行界面程序包，该包仅用于可执行文件，而不是库依赖项的一部分。"

#: ../../pages/tutorial/dependencies.md:118
msgid ""
"We restructure our main program a bit for using [M\\_CLI2] to handle the "
"command line input. The *unnamed* array contains all positional command "
"line arguments, we still use the first two as pattern and replacement, "
"and use all remaining arguments as input. We also add an option to "
"redirect the output. Our final main program looks like"
msgstr "我们稍微重构了一下主程序，以便使用[M_CLI2](https://github.com/urbanjost/M_CLI2)来处理命令行输入。*未命名的*数组包含所有位置命令行参数，我们仍然使用前两个作为模式和替换，并使用所有剩余的参数作为输入。我们还添加了一个选项来重定向输出。最终主程序像这样："

#: ../../pages/tutorial/dependencies.md:130
msgid "Again we run a quick check using fpm"
msgstr "我们再次使用fpm运行快速检查："

#: ../../pages/tutorial/dependencies.md:152
msgid "The output looks as expected with two substitutions."
msgstr "输出看起来与预期一样，有两个替换。"

#: ../../pages/tutorial/dependencies.md:155
#: ../../pages/tutorial/hello-fpm.md:97 ../../pages/tutorial/plugins.md:90
msgid "Summary"
msgstr "总结"

#: ../../pages/tutorial/dependencies.md:157
#: ../../pages/tutorial/hello-fpm.md:99 ../../pages/tutorial/plugins.md:92
msgid "In this tutorial you learned how to"
msgstr "在本教程中，你学习了如何"

#: ../../pages/tutorial/dependencies.md:159
msgid "depend on another fpm project in the package manifest"
msgstr "在包清单中添加对另一个fpm项目的依赖；"

#: ../../pages/tutorial/dependencies.md:160
msgid "add development dependencies for testing"
msgstr "添加用于测试的开发依赖项；"

#: ../../pages/tutorial/dependencies.md:161
msgid "use dependencies for executables"
msgstr "使用可执行文件的依赖项。"

#: ../../pages/tutorial/hello-fpm.md:1
msgid "First steps with fpm"
msgstr "使用fpm的第一步"

#: ../../pages/tutorial/hello-fpm.md:3
msgid ""
"This tutorial covers the basic usage of the Fortran Package Manager (fpm)"
" command line. It will cover the generation of a new project and the "
"possibility to compile a project into an executable as well as the "
"possibility to run the resulting program."
msgstr "本教程介绍了Fortran包管理器（fpm）的命令行基本用法。它涵盖新项目的生成、将项目编译为可执行文件的可能性以及运行结果程序的可能性。"

#: ../../pages/tutorial/hello-fpm.md:6
msgid "To start a new project with fpm use the *fpm new* command"
msgstr "要使用fpm新建项目，请使用*fpm new*命令:"

#: ../../pages/tutorial/hello-fpm.md:12
msgid ""
"By default fpm creates a git repository with a dummy project in the fpm "
"standard layout"
msgstr "默认情况下，fpm使用fpm标准布局中的式样项目创建一个git存储库："

#: ../../pages/tutorial/hello-fpm.md:30
msgid ""
"This is everything we need to start our new project. First, we inspect "
"the package manifest, ``fpm.toml``, which is populated with stub entries "
"for us:"
msgstr "这就是我们开始新项目所需的一切。首先，我们检查包清单``fpm.toml``，它为我们填充了存根条目："

#: ../../pages/tutorial/hello-fpm.md:49
msgid ""
"The package manifest contains all the required meta data for the new "
"project. Next we checkout the main executable, ``app/main.f90``, fpm has "
"generated for us:"
msgstr "包清单包含新项目所需的所有元数据。接下来，我们检查主可执行文件``app/main.f90``，fpm已经为我们生成："

#: ../../pages/tutorial/hello-fpm.md:62
msgid ""
"The program already uses a module from our library, which we can find in "
"``src/first_steps.f90``:"
msgstr "该程序已经使用了我们库中的一个模块，我们可以在以下位置``src/first_steps.f90``找到该模块："

#: ../../pages/tutorial/hello-fpm.md:64
msgid "src/first_steps.f90"
msgstr ""

#: ../../pages/tutorial/hello-fpm.md:78
msgid "We can run the executable directly with the command ``fpm run``:"
msgstr "我们可以直接使用以下命令``fpm run``运行可执行文件："

#: ../../pages/tutorial/hello-fpm.md:86
msgid ""
"Similarly, fpm has already created a stub for testing, which can be "
"invoked with ``fpm test``:"
msgstr "类似地，fpm会创建了一个用于测试的存根，可以使用命令``fpm test``调用："

#: ../../pages/tutorial/hello-fpm.md:94
msgid ""
"Fpm will automatically track changes in your project when running your "
"project using the *run* and *test* commands."
msgstr "fpm将在使用运行命令（*run*）和测试命令（*test*）运行项目时自动跟踪项目中的更改。"

#: ../../pages/tutorial/hello-fpm.md:101
msgid "create a new project from the fpm command line"
msgstr "从fpm命令行创建新项目；"

#: ../../pages/tutorial/hello-fpm.md:102
msgid "build and run your project executables with fpm"
msgstr "使用fpm构建和运行项目可执行文件；"

#: ../../pages/tutorial/hello-fpm.md:103
msgid "run tests with fpm"
msgstr "使用fpm运行测试。"

#: ../../pages/tutorial/index.md:3
msgid "Tutorials"
msgstr "教程"

#: ../../pages/tutorial/index.md:6
msgid ""
"This section contains courses for learning about the usage and fpm at "
"specific examples."
msgstr "本节包含用于了解特定示例的用法和fpm的教程。"

#: ../../pages/tutorial/plugins.md:1
msgid "Extending fpm with plugins"
msgstr "使用插件扩展fpm"

#: ../../pages/tutorial/plugins.md:3
msgid ""
"The Fortran package manager has a plugin system which allows to easily "
"extend its functionality. This tutorial will show how to install a plugin"
" with fpm and use it."
msgstr "Fortran包管理器有一个插件系统，可以轻松扩展其功能。本教程将展示如何使用fpm安装插件并使用它。"

#: ../../pages/tutorial/plugins.md:7
msgid "Registry search tool"
msgstr "注册表搜索工具"

#: ../../pages/tutorial/plugins.md:9
#, fuzzy
msgid ""
"The [fpm-search](https://github.com/urbanjost/fpm-search) project is a "
"plugin to query the package registry. Since it is built with fpm we can "
"easily install it on our system with"
msgstr ""
"[fpm-search](https://github.com/brocolis/fpm-"
"search)项目是一个用于查询包注册表的插件。由于它是使用fpm构建的，因此我们可以轻松地将其安装在我们的系统上："

#: ../../pages/tutorial/plugins.md:18
msgid ""
"This will install the ``fpm-search`` binary to ``~/.local/bin`` (or "
"``%APPDATA%\\local\\bin`` on Windows)."
msgstr ""
"这会将二进制文件``fpm-"
"search``安装到``~/.local/bin``（或在Windows上的``%APPDATA%\\local\\bin``）。"

#: ../../pages/tutorial/plugins.md:21
msgid "Ensure that the installed binary is in the ``PATH``, *i.e.* run"
msgstr "确保安装的二进制文件位于环境路径（``PATH``）中，即运行："

#: ../../pages/tutorial/plugins.md:28
msgid "If no binary is found, add the directory to your path using"
msgstr "如果未找到二进制文件，请使用："

#: ../../pages/tutorial/plugins.md
msgid "Bash (Linux)"
msgstr ""

#: ../../pages/tutorial/plugins.md:34
msgid ""
"Default settings for the bash shell can be found in the ``.bashrc`` file "
"in the home directory, to append to the ``PATH`` following the "
"instructions below."
msgstr "bash shell的默认设置可以在主目录的``.bashrc``中找到，根据以下说明以附加到环境路径（``PATH``）："

#: ../../pages/tutorial/plugins.md:41
msgid ""
"Make sure to source your ``.bashrc`` after changing it, otherwise the "
"change will not be applied to the current shell."
msgstr "确保在更改``.bashrc``后载入它，否则更改将不会应用于当前shell。"

#: ../../pages/tutorial/plugins.md
msgid "Zsh (MacOS)"
msgstr ""

#: ../../pages/tutorial/plugins.md:45
msgid ""
"Default settings for the zsh shell can be found in the ``.zshrc`` file in"
" the home directory, to append to the ``PATH`` use"
msgstr "zsh shell的默认设置可以在主目录的``.zshrc``文件中找到，以附加到环境路径（``PATH``）使用："

#: ../../pages/tutorial/plugins.md:52
msgid ""
"Make sure to restart zsh after changing the ``.zshrc`` it, otherwise the "
"change will not be applied to the current shell."
msgstr "确保在更改``.zshrc``后重新启动zsh，否则更改将不会应用于当前shell。"

#: ../../pages/tutorial/plugins.md
msgid "CMD (Windows)"
msgstr ""

#: ../../pages/tutorial/plugins.md:56
msgid ""
"The ``PATH`` variable can be modified using the pathman program from the "
"cmd prompt"
msgstr "可以使用cmd提示符中的路径程序修改变量``PATH``："

#: ../../pages/tutorial/plugins.md:64
msgid "Now with a working installation we can invoke our new plugin from fpm."
msgstr "现在，通过之前的安装工作，我们可以从fpm调用我们的新插件。"

#: ../../pages/tutorial/plugins.md:72
msgid ""
"Note that we use ``fpm search`` rather than ``fpm-search`` in the "
"command. To find a package for building a command-line interface we can "
"now type"
msgstr "请注意，我们使用``fpm search``而不是在命令中使用``fpm-search``。要查找用于构建命令行界面的包，我们现在可以键入："

#: ../../pages/tutorial/plugins.md:81
msgid ""
"To use one of the packages in our manifest we can generate the necessary "
"dependency line by running"
msgstr "要使用清单中的某个包，我们可以通过以下方式生成必要的依赖关系行："

#: ../../pages/tutorial/plugins.md:88
msgid ""
"Adding this line to a package manifest allows to depend on the respective"
" project."
msgstr "将此行添加到包清单以允许依赖于相应的项目。"

#: ../../pages/tutorial/plugins.md:94
msgid "installing an fpm plugin"
msgstr "安装fpm插件；"

#: ../../pages/tutorial/plugins.md:95
msgid "use the fpm-search plugin to query the registry"
msgstr "使用fpm搜索插件查询注册表；"

#: ../../pages/tutorial/plugins.md:96
msgid "generate a dependency entry from a query result"
msgstr "根据查询结果生成依赖项条目。"

#~ msgid ""
#~ "To work with deferred length characters"
#~ " we added a small helper function "
#~ "to read a whole line."
#~ msgstr ""

